# -*- coding: utf-8 -*-
"""tpe.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1WQJetdai9mitAsR8Xke9BRMok7frjxVc

#**TPE : Fundamentos de la ciencia de datos**
Base de datos: calidad_del_agua_2023

Integrantes:
*   Acevedo Belen
*   Artaza Sheila
*   Meresman Eden

Lo primero que realizamos aqui es la descarga de los archivos brindados por la catedra.
"""

!pip install wget
import wget
from os import path, listdir

# ID del archivo en Google Drive
file_id = '1XLWpKSWFimUteORTUizrgKCE8ew7xAet'  # Reemplaza con el ID del archivo CSV
url = f'https://drive.google.com/uc?id={file_id}'

# Nombre del archivo que se va a descargar
filename = 'archivo.csv'

# Verifica si el archivo ya existe
if path.exists(filename):
    print(f'El archivo "{filename}" ya se encuentra descargado.')
else:
    # Si no existe, descarga el archivo
    filename = wget.download(url, filename)
    print(f'\nArchivo descargado: {filename}')

# Chequeamos si los archivos están en el directorio donde estamos parados
lista_archivos = listdir("./")
print(f"El contenido de la carpeta es: {lista_archivos}")

"""Cambiamos el delimitador a ";" para poder leer correctamente el archivo.csv


"""

import pandas as pd

df = pd.read_csv('archivo.csv', sep=';')

"""**ANÁLISIS**

Realizamos la vista preliminar del archivo.
"""

print(df)
df.info()
df.describe()
df.head()

"""Realizamos un analisis de las variables para conocer las variables disponibles, para ellos vimos las frecuencias y porcentajes de las distintas variables
Dejamos un ejemplo adjunto.
"""

import pandas as pd

frecuencias = df['sitios'].value_counts()
porcentajes = df['sitios'].value_counts(normalize=True) * 100

print(frecuencias)
print(porcentajes)

"""Contamos la cantidad de Nans por variable."""

import pandas as pd
cantidad_nulos = df.isna().sum()
print(cantidad_nulos)

"""Copiamos el archivo para preservar los datos."""

base_limpia = df.copy()

"""**LIMPIEZA**

Borramos las columnas "codigo", "año", "fecha", "sitios",  que no consideramos necesarias para el análisis.
"""

base_limpia = base_limpia.drop(columns=['codigo'])
base_limpia = base_limpia.drop(columns=['año'])

"""Reemplazamos con Nans los valores que no brindaban información como "no se muestreó" para cada una de las variables."""

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'sin equipo', 'inaccesible']
base_limpia['tem_agua'] = base_limpia['tem_agua'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'sin equipo', 'inaccesible']
base_limpia['tem_aire'] = base_limpia['tem_aire'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'sin equipo', 'inaccesible']
base_limpia['od'] = base_limpia['od'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'sin equipo', 'inaccesible', 'no funcionó', '-', ' ']
base_limpia['ph'] = base_limpia['ph'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['olores'] = base_limpia['olores'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['color'] = base_limpia['color'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['espumas'] = base_limpia['espumas'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['mat_susp'] = base_limpia['mat_susp'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó','envase sin muestra', 'sin muestra', 'inaccesible']
base_limpia['colif_fecales_ufc_100ml'] = base_limpia['colif_fecales_ufc_100ml'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó','envase sin muestra', 'sin muestra', 'inaccesible']
base_limpia['escher_coli_ufc_100ml'] = base_limpia['escher_coli_ufc_100ml'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó','envase sin muestra', 'sin muestra', 'inaccesible']
base_limpia['enteroc_ufc_100ml'] = base_limpia['enteroc_ufc_100ml'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['nitrato_mg_l'] = base_limpia['nitrato_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['nh4_mg_l'] = base_limpia['nh4_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible', ' ']
base_limpia['p_total_l_mg_l'] = base_limpia['p_total_l_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible', 'sin muestra']
base_limpia['fosf_ortofos_mg_l'] = base_limpia['fosf_ortofos_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['dbo_mg_l'] = base_limpia['dbo_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['dqo_mg_l'] = base_limpia['dqo_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['turbiedad_ntu'] = base_limpia['turbiedad_ntu'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible','sin muestra']
base_limpia['hidr_deriv_petr_ug_l'] = base_limpia['hidr_deriv_petr_ug_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['cr_total_mg_l'] = base_limpia['cr_total_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['cd_total_mg_l'] = base_limpia['cd_total_mg_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible', 'falto un frasco']
base_limpia['clorofila_a_ug_l'] = base_limpia['clorofila_a_ug_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible', 'Dato atípico']
base_limpia['microcistina_ug_l'] = base_limpia['microcistina_ug_l'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', 'no se midió', 'no se muestreó','no muestreó', 'inaccesible', 'N/A', 'no se pudo calcular']
base_limpia['ica'] = base_limpia['ica'].replace(valores_a_reemplazar, pd.NA)

valores_a_reemplazar = ['en obra', ' ' ,'no se midió', 'no se muestreó','no muestreó', 'inaccesible']
base_limpia['calidad_de_agua'] = base_limpia['calidad_de_agua'].replace(valores_a_reemplazar, pd.NA)

"""Contamos nuevamente la cantidad de Nans de cada variable."""

base_limpia.info()

"""Eliminamos los "<" y ">" de las variables que los poseian. Además las convertimos a un tipo númerico."""

base_limpia['nitrato_mg_l'] = pd.to_numeric(
    base_limpia['nitrato_mg_l'].replace({'<2.0': '2.0','<44': '44'}, regex=True),
    errors='coerce'
)
base_limpia['nh4_mg_l'] = pd.to_numeric(
    base_limpia['nh4_mg_l'].replace({'<0.05': '0.05','<0.1':'0.1','<0.78':'0.78'}, regex=True),
    errors='coerce'
)
base_limpia['p_total_l_mg_l'] = pd.to_numeric(
    base_limpia['p_total_l_mg_l'].replace({'<0.10': '0.10'}, regex=True),
    errors='coerce'
)
base_limpia['fosf_ortofos_mg_l'] = pd.to_numeric(
        base_limpia['fosf_ortofos_mg_l'].replace({'<0.20': '0.20','<0.10':'0.10'}, regex=True),
        errors='coerce'
    )
base_limpia['hidr_deriv_petr_ug_l'] = pd.to_numeric(
        base_limpia['hidr_deriv_petr_ug_l'].replace({'<0.10': '0.10'}, regex=True),
        errors='coerce'
    )
base_limpia['cr_total_mg_l'] = pd.to_numeric(
        base_limpia['cr_total_mg_l'].replace({'<0.005': '0.005'}, regex=True),
        errors='coerce'
    )
base_limpia['cd_total_mg_l'] = pd.to_numeric(
        base_limpia['cd_total_mg_l'].replace({'<0.001': '0.001', '<1.0':'1.0'}, regex=True),
        errors='coerce'
    )
base_limpia['clorofila_a_ug_l'] = pd.to_numeric(
        base_limpia['clorofila_a_ug_l'].replace({'<10.00': '10.00','<0.10':'0.10'}, regex=True),
        errors='coerce'
    )
base_limpia['dbo_mg_l'] = pd.to_numeric(
        base_limpia['dbo_mg_l'].replace({'<2.0': '2.0', '<5' :'5'}, regex=True),
        errors='coerce'
    )
base_limpia['dqo_mg_l'] = pd.to_numeric(
        base_limpia['dqo_mg_l'].replace({'<30': '30','<50':'50'}, regex=True),
        errors='coerce'
    )
base_limpia['microcistina_ug_l'] = pd.to_numeric(
        base_limpia['microcistina_ug_l'].replace({ '<0.15': '0.15', '>5.00' : '5.00'}, regex=True),
        errors='coerce'
    )

"""Convertimos las variables cualitativas en binarias."""

base_limpia['olores'] = base_limpia['olores'].replace({'Ausencia':0, 'Presencia' : 1})
base_limpia['color'] = base_limpia['color'].replace({'Ausencia':0, 'Presencia' : 1})
base_limpia['espumas'] = base_limpia['espumas'].replace({'Ausencia':0, 'Presencia' : 1})
base_limpia['mat_susp'] = base_limpia['mat_susp'].replace({'Ausencia':0, 'Presencia' : 1})
base_limpia['calidad_de_agua'] = base_limpia['calidad_de_agua'].replace({'Muy deteriorada':0, 'Extremadamente deteriorada' : 1})

"""Copiamos la base limpia, para continuar con la exploración. Eliminamos las filas que poseen mas del 60% de sus valores con Nans.

Además copiamos los valores de la variable "campaña" para luego eliminarla.
"""

base_limpia_matriz = base_limpia.copy()
import pandas as pd
umbral = 0.4  # 1 - 0.6 (60%)

base_limpia_matriz = base_limpia_matriz.dropna(thresh=int(umbral * base_limpia_matriz.shape[1]))
campaña = base_limpia_matriz['campaña']
base_limpia_matriz = base_limpia_matriz.drop(columns=['campaña'])

"""Convertimos todos los valores de la matriz a formato float y utilizamos el comando coerce para que convierta los valores que no se pueden procesar en Nan en lugar de generar un error."""

import pandas as pd
for col in base_limpia_matriz.columns:
    if base_limpia_matriz[col].dtype == 'object':
        base_limpia_matriz[col] = pd.to_numeric(base_limpia_matriz[col] , errors = 'coerce')

"""Realizamos imputación por el algoritmo de vecinos más cercanos para todas las filas que poseian en alguna de sus variables un Nan, debido a que no tenian distribución normal.
El valor de vecinos elegido fue k=7.
"""

from sklearn.impute import KNNImputer
import pandas as pd

columnas_no_normales = ['tem_agua', 'tem_aire', 'colif_fecales_ufc_100ml', 'escher_coli_ufc_100ml',
    'enteroc_ufc_100ml', 'p_total_l_mg_l', 'fosf_ortofos_mg_l', 'dbo_mg_l',
    'clorofila_a_ug_l', 'microcistina_ug_l', 'ica','hidr_deriv_petr_ug_l','calidad_de_agua','ph','od']

imputer = KNNImputer(n_neighbors=7)
#imputa las columnas seleccionadas
base_limpia_matriz[columnas_no_normales] = imputer.fit_transform(base_limpia_matriz[columnas_no_normales])

#eliminamos las variables que no utilizaremos
base_limpia_matriz = base_limpia_matriz.drop(columns=['sitios'])
base_limpia_matriz = base_limpia_matriz.drop(columns=['fecha'])
base_limpia_matriz = base_limpia_matriz.drop(columns=['orden'])

"""Para revisar que se haya imputado correctamente contamos la cantidad de Nans de las variables afectadas."""

cantidad_nulos = base_limpia_matriz.isna().sum()
print("Cantidad de valores NaN por variable:")
cantidad_nulos

"""Guardamos las columnas cualitativas para luego poder eliminarlas de la copia. Además eliminamos la variable continua (que posee un único valor constante) "hidr_deriv_petr_ug_l".

"""

base_completa = base_limpia_matriz

base_limpia_matriz = base_limpia_matriz.drop(columns=['hidr_deriv_petr_ug_l'])
base_limpia_matriz = base_limpia_matriz.drop(columns=['olores'])
base_limpia_matriz = base_limpia_matriz.drop(columns=['color'])
base_limpia_matriz = base_limpia_matriz.drop(columns=['espumas'])
base_limpia_matriz = base_limpia_matriz.drop(columns=['mat_susp'])
base_limpia_matriz = base_limpia_matriz.drop(columns=['calidad_de_agua'])

"""**EXPLORACIÓN**

Realizamos los histogramas de las variables cuantitativas para conocer su distribución.
"""

import matplotlib.pyplot as plt

plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['tem_agua'], bins=30, edgecolor='black')
plt.xlabel('Temperatura del Agua')
plt.ylabel('Frecuencia')
plt.title('Histograma de Temperatura del Agua')
plt.xticks(rotation=45, ha='right') # rotar las etiquetas
plt.tight_layout() # ajustar el diseño para evitar superposiciones
plt.show()

"""Sesgado a izquierda"""

import matplotlib.pyplot as plt

plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['tem_aire'], bins=30, edgecolor='black')
plt.xlabel('Temperatura del Aire')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable tem_aire')
plt.xticks(rotation=45, ha='right') # rotar las etiquetas
plt.tight_layout() #ajustar el diseño
plt.show()

"""Comportamiento bimodal"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['od'], bins=30, edgecolor='black')
plt.xlabel('Oxigeno disuelto')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable od')
plt.xticks(rotation=45, ha='right') #rotar las etiquetas
plt.tight_layout() #ajustar el diseño
plt.show()

"""Comportamiento levemente sesgado a izquierda"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['ph'], bins=30, edgecolor='black')
plt.xlabel('Medida del ph del agua')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable ph')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento levemente sesgado a izquierda"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['colif_fecales_ufc_100ml'], bins=30, edgecolor='black')
plt.xlabel('Medida de colonias de coliformes fecales en 100 ml de agua')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable colif_fecales_ufc_100ml')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Muestra una frecuencia alta en torno a valores colonias coliformes fecales  bajos"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['escher_coli_ufc_100ml'], bins=30, edgecolor='black')
plt.xlabel('Medida de colonias de escherichia coli en 100 ml de agua')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable escher_coli_ufc_100ml')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Muestra una frecuencia alta en torno a valores de colonias de escherichia coli bajos"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['enteroc_ufc_100ml'], bins=30, edgecolor='black')
plt.xlabel('Medida de colonias de enterococos en 100 ml de agua')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable enteroc_ufc_100ml')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Muestra una frecuencia alta en torno a valores de colonias de enterococos bajos"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['nitrato_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de concentracion de nitratos por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable nitrato_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['nh4_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de concentracion de amonio por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable nh4_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['p_total_l_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de fosforo total por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable p_total_l_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['fosf_ortofos_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de concentracion de ortofosfatos por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable fosf_ortofos_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda"""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['dbo_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de demanda biologica de oxigeno por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable dbo_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda."""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['dqo_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de demanda quimica de oxigeno por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable dqo_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda."""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['turbiedad_ntu'], bins=30, edgecolor='black')
plt.xlabel('Medida de la turbidez del agua')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable turbiedad_ntu')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda."""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['cr_total_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de concentracion de cromo por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable cr_total_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Presenta un comportamiento con mucha frecuencia sobre valores bajos de concentracion de cromo por litro."""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['cd_total_mg_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de concentracion de cadmio por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable cd_total_mg_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Presenta un comportamiento con frecuencia en dos valores sobre la concentracion de cadmio por litro."""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['clorofila_a_ug_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de concentracion de clorofila por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable clorofila_a_ug_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Comportamiento sesgado a izquierda."""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['microcistina_ug_l'], bins=30, edgecolor='black')
plt.xlabel('Medida de concentracion de microcistinas por litro')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable microcistina_ug_l')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Presenta un comportamiento con mayor frecuencia de valores bajos sobre la concentracion de microcistinas por litro."""

import matplotlib.pyplot as plt
plt.figure(figsize=(6, 6))
plt.hist(base_limpia_matriz['ica'], bins=30, edgecolor='black')
plt.xlabel('Medida del indice de calidad del agua')
plt.ylabel('Frecuencia')
plt.title('Histograma de la variable ica')
plt.xticks(rotation=45, ha='right')
plt.tight_layout()
plt.show()

"""Presenta un comportamiento sesgado a izquierda.

Realizamos la matriz de correlaciones de Pearson de las variables cuantitativas para ver si hay posibles relaciones lineales entre las variables.
"""

correlation_matrix = base_limpia_matriz.corr()
correlation_matrix

"""La mostramos utilizando un mapa de color para hacer enfasis en aquellas posibles relaciones fuertes. Tomamos un valor de correlación  absoluto mayor a 0,67."""

import seaborn as sns
import matplotlib.pyplot as plt

plt.figure(figsize=(16,12))
sns.heatmap(correlation_matrix, vmin=-1.0, vmax=1.0, center=0.0, annot=True, cmap= 'coolwarm')
plt.show()

import matplotlib.pyplot as plt
import numpy as np

correlation_matrix_umbralizada = correlation_matrix.abs() > 0.67
# sacamos la diagonal
np.fill_diagonal(correlation_matrix_umbralizada.values, 0)

plt.figure(figsize=(16,12));
sns.heatmap(correlation_matrix_umbralizada, vmin=0.0, vmax=1.0, center=0.0, annot=True, cmap= 'coolwarm')
plt.show()

"""Realizamos para cada una de las posibles relaciones un scatter plot, para ver si la relacion era lineal (podriamos ver una recta) o no."""

for i, col in enumerate(correlation_matrix_umbralizada.columns):
  for j in range(i,len(correlation_matrix_umbralizada.index)):
    # extraemos el nombre de la fila en la que estamos
    row = correlation_matrix_umbralizada.index[j]
    # si en esa posición tenemos un True en la matriz umbralizada
    if correlation_matrix_umbralizada.loc[row, col]:
      # nos traemos el valor de esa correlación
      correlation = correlation_matrix.loc[row, col]
      plt.figure(figsize=(6, 6))
      plt.scatter(base_limpia_matriz[row], base_limpia_matriz[col])

      plt.title(f"Scatter plot entre {col} y {row} - r = {correlation:.4f}")
      plt.xlabel(row)
      plt.ylabel(col)
      plt.grid(True)
      plt.show()

"""Al ver que la turbiedad del agua tiene una fuerte correlación con la clorofila y la demanda quimica de oxigeno, surge nuestra primer hipótesis:

**H1: ¿La turbiedad del agua se ve influenciada por la presencia de clorofila en el agua y por la demanda quimica de oxigeno?**

Realizamos primeramente un grafico de reducción de dimensionalidad PCA sobre "clorofila_a_ug_l" y "dqo_mg_l" pintadas por "turbiedad_ntu".
"""

plt.figure(figsize=(8, 6))
scatter = plt.scatter(base_completa['dqo_mg_l'], base_completa['clorofila_a_ug_l'], c=base_completa['turbiedad_ntu'], cmap='viridis')
plt.xlabel('DQO (mg/l)')
plt.ylabel('Clorofila a (ug/l)')
plt.title('Relación entre DQO, Clorofila y Turbidez')
plt.colorbar(scatter, label='Turbidez (NTU)')
plt.show()

"""Como vemos un cierto comportamiento no lineal, decidimos realizar finalmente un grafico en 3D para complementarlo."""

import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D

X = base_completa['dqo_mg_l']
Y = base_completa['clorofila_a_ug_l']
Z = base_completa['turbiedad_ntu']

#crear malla para la superficie
x_grid, y_grid = np.meshgrid(np.linspace(X.min(), X.max(), 100),
                             np.linspace(Y.min(), Y.max(), 100))

#interpolación para obtener valores de Z (turbiedad) en la malla
from scipy.interpolate import griddata
z_grid = griddata((X, Y), Z, (x_grid, y_grid), method='linear')

#crear el gráfico de superficie
fig = plt.figure(figsize=(12, 8))
ax = fig.add_subplot(111, projection='3d')
surf = ax.plot_surface(x_grid, y_grid, z_grid, cmap='viridis', edgecolor='none')

ax.set_xlabel('dqo_mg_l')
ax.set_ylabel('clorofila_a_ug_l')
ax.set_zlabel('turbiedad_ntu')
ax.set_title('Influencia de "dqo_mg_l" y "clorofila_a_ug_l" sobre "turbiedad_ntu"')
fig.colorbar(surf, label='turbiedad_ntu')

plt.show()

"""Como la relación es creciente, se ve que a menor proporción de demanda quimica de oxigeno y clorofila disminuye la turbidez del agua.
Por ende **la hipótesis H1 queda validada.**

Nos interesamos en el indice de la calidad del agua y surgió nuestra segunda hipótesis:

**H2: ¿El índice de calidad del agua se ve influenciado por  las características físico químicas y microbiológicas registradas?**

Realizamos primeramente un gráfico de reducción de dimensionalidad PCA con las variables fisico-quimicas (como tem_agua, ph, etc) y las microbiologicas (como escher_coli_ufc_100ml, clorofila_a_ug_l, etc) pintadas sobre ica.
"""

from sklearn.decomposition import PCA
from sklearn.preprocessing import StandardScaler
calidad = base_completa['ica']
# Seleccionar las variables para el PCA sin la variable 'ica'
variables_pca = base_completa.drop(['ica'], axis=1)

# Estandarizar las variables
x = StandardScaler().fit_transform(variables_pca)

# Crear el objeto PCA
pca = PCA(n_components=2) # Reducir a 2 componentes principales

# Ajustar el modelo PCA a los datos
principalComponents = pca.fit_transform(x)

# Crear un nuevo DataFrame con los componentes principales
principalDf = pd.DataFrame(data = principalComponents, columns = ['principal component 1', 'principal component 2'])

# Agregar la variable 'ica' al DataFrame
finalDf = pd.concat([principalDf, base_completa['ica']], axis = 1)

# Gráfico de dispersión de los componentes principales pintados por 'ica'
plt.figure(figsize=(8, 6))
plt.scatter(finalDf['principal component 1'], finalDf['principal component 2'], c=finalDf['ica'], cmap='viridis')
plt.xlabel('Primer componente principal')
plt.ylabel('Segundo componente principal')
plt.title('PCA de todas las variables pintado por ica')
plt.colorbar(label='ica')
plt.show()

# Mostrar la varianza explicada por cada componente principal
print('Varianza explicada por cada componente principal:', pca.explained_variance_ratio_)

base_completa.columns

pca.__dict__

"""Vemos que este PCA solo representa un 35%, por lo que decidimos proceder con una reduccion de la dimensionalidad mediante T-sne"""

from sklearn.manifold import TSNE
X_tsne = TSNE(n_components=2, random_state=10).fit_transform(x)

plt.scatter(X_tsne[:,0], X_tsne[:,1],c=calidad.values, cmap='viridis')
plt.grid(True)
plt.xlabel('Componente 1 t-SNE')
plt.ylabel('Component 2 t-SNE')
plt.title('Representación t-SNE del conjunto en base a ica')
plt.colorbar()
plt.show()

"""Como este gráfico no nos permite ver ningun tipo de comportamiento, **la** **hipótesis H2 es refutada**.

Decidimos entonces, reducir el conjunto de características para seguir explorando el indice de la calidad del agua y su comportamiento. Surge entonces nuestra tercer hipótesis:

**H3: ¿Influyen las colonias fecales en el indice de la calidad del agua?**

Realizamos primeramente un gráfico de reducción de dimensionalidad PCA con las tres bacterias fecales "enteroc_ufc_100ml", "colif_fecales_ufc_100ml" y "escher_coli_ufc_100ml" pintadas por "ica"
"""

x = base_completa[['colif_fecales_ufc_100ml', 'escher_coli_ufc_100ml', 'enteroc_ufc_100ml']].copy()

scaler = StandardScaler()
X_scaled = scaler.fit_transform(x)
pca = PCA(n_components=2, whiten=False)
principalComponents = pca.fit_transform(X_scaled)

plt.figure(figsize=(8, 8))
plt.scatter(principalComponents[:, 0], principalComponents[:, 1], c=base_completa['ica'], cmap='viridis')
plt.colorbar(label='Indice de calidad de agua')
plt.xlabel('Proyección PCA 1')
plt.ylabel('Proyección PCA 2')
plt.title('Proyección PCA en función del indice de la de agua')
plt.grid(True)

plt.xlim([-1, 4])
plt.ylim([-3, 2])

plt.show()

pca.__dict__

"""Vemos que el gráfico nos muestra un comportamiento entre las variables fecales y la variable ICA, aumentando de izquierda a derecha.
Nos permite dar un paso más para validar la hipótesis, ya que el PCA representa un 90%.

La variable 'ica' es una variable continua que a simple vista por el histograma no presenta una distribucion normal. Por ende, decidimos crear una nueva variable de tipo cualitativa llamada 'ica_cualitativa' la cual divide en tres grupos a la misma. Dandonos tres categorias: 'Calidad alta', 'Calidad media' y 'Calidad baja'
"""

def categorize_ica(df):
  """Categorizes ICA values into 'Baja', 'Media', and 'Alta' quality."""
  conditions = [
      df['ica'] < 35,
      (df['ica'] >= 35) & (df['ica'] <= 45),
      df['ica'] > 45
  ]
  choices = ['Baja', 'Media', 'Alta']
  df['ica_cualitativa'] = np.select(conditions, choices, default='Sin clasificación')
  return df


base_limpia_matriz = categorize_ica(base_completa)


# Count the number of samples in each category
sample_counts = base_limpia_matriz['ica_cualitativa'].value_counts()
sample_counts

variables_bacterianas = ['colif_fecales_ufc_100ml', 'escher_coli_ufc_100ml', 'enteroc_ufc_100ml']
colores = {'Media': 'blue', 'Alta': 'green', 'Baja': 'red'}
for variable in variables_bacterianas:
    plt.figure(figsize=(8, 5))

    # Agrupar los datos por 'ica_cualitativa' y calcular la media de la variable bacteriana
    data_agrupada = base_completa.groupby('ica_cualitativa')[variable].mean()

    # Reordenar los datos en el orden deseado
    orden_categorias = ['Baja', 'Media', 'Alta']
    data_agrupada = data_agrupada.reindex(orden_categorias)

    # Crear el gráfico de barras
    data_agrupada.plot(kind='bar', color=[colores[categoria] for categoria in orden_categorias])

    # Configurar el título y las etiquetas
    plt.title(f'Media de {variable} por categoría de ICA')
    plt.xlabel('Categoría de ICA (Cualitativa)')
    plt.ylabel(f'Media de {variable}')
    plt.xticks(rotation=0)

    # Mostrar el gráfico
    plt.tight_layout()
    plt.show()

"""Podemos observar una diferencia significativa en el promedio de cantidad de bacterias fecales dependiendo de que tipo de calidad de agua es. Esto nos permite buscar algun test de hipotesis que se amolde a nuestras variables para poder confirmar o refutar nuestra hipotesis. Para eso analizamos a traves del test de Shapiro-Wilk, histograma y QQ-PLOT si nuestras variables continuas presentan o no una distribucion normal."""

import matplotlib.pyplot as plt
import seaborn as sns
from scipy.stats import shapiro, levene
from statsmodels.graphics.gofplots import qqplot
from scipy.stats import f_oneway


for var in variables_bacterianas:
    data = base_completa[var]

    plt.figure(figsize=(8, 6))
    sns.histplot(data, kde=True)
    plt.title(f'Histograma de {var}')
    plt.xlabel(var)
    plt.ylabel('Frecuencia')
    plt.show()

    # QQ-plot
    plt.figure(figsize=(8, 6))
    qqplot(data, line='s')
    plt.title(f'QQ-plot de {var}')
    plt.xlabel('Cuantiles Teóricos')
    plt.ylabel('Cuantiles Muestra')
    plt.show()

    # Test de Shapiro-Wilk
    stat, p = shapiro(data)
    print(f"Test de Shapiro-Wilk para {var}:")
    print(f"Estadístico: {stat}")
    print(f"Valor p: {p}")

    if p > 0.05:
        print("No se rechaza la hipótesis nula: la muestra puede provenir de una distribución normal.\n")
    else:
        print("Se rechaza la hipótesis nula: la muestra no proviene de una distribución normal.\n")

"""Concluimos que ninguna de nuestras variables continuas bacterianas poseen una distribucion normal. Continuamos realizando un test de Levenne para ver la diferencia de varianzas entre las variables continuas frente a la variable cualitativa (la cual posee 3 categorias) por ende utilizamos el test de Levenne"""

from scipy.stats import levene

for variable in variables_bacterianas:
  # Obtener los datos de cada grupo (ICA cualitativa)
  grupo_bajo = base_completa[base_completa['ica_cualitativa'] == 'Baja'][variable]
  grupo_medio = base_completa[base_completa['ica_cualitativa'] == 'Media'][variable]
  grupo_alto = base_completa[base_completa['ica_cualitativa'] == 'Alta'][variable]

  # Realizar el test de Levene
  stat, p = levene(grupo_bajo, grupo_medio, grupo_alto)

  print(f"Test de Levene para {variable} vs. ica_cualitativa:")
  print(f"Estadístico: {stat}")
  print(f"Valor p: {p}")

  if p > 0.05:
    print(f"Las varianzas de {variable} son iguales entre los grupos de ica_cualitativa. Hay homocedasiticidad")
  else:
    print(f"Las varianzas de {variable} no son iguales entre los grupos de ica_cualitativa. No hay homocedasticidad")
  print("---")

"""Al corroborar que nuestras variables continuas no presentan una distribucion normal ni homocedasticidad. Utilizaremos el test no parametrico de Kruskal-Wallis para confirmar o refutar nuestra hipotesis."""

from scipy.stats import kruskal

# Filtrar el DataFrame para obtener solo las filas con las categorías deseadas
df_filtered = base_completa[base_completa['ica_cualitativa'].isin(['Alta', 'Media', 'Baja'])]

for variable in variables_bacterianas:
  groups = [df_filtered[variable][df_filtered['ica_cualitativa'] == 'Alta'],
            df_filtered[variable][df_filtered['ica_cualitativa'] == 'Media'],
            df_filtered[variable][df_filtered['ica_cualitativa'] == 'Baja']]

  stat, p = kruskal(*groups)
  print(f"Test de Kruskal-Wallis para {variable} frente a ica_cualitativa:")
  print(f"Estadístico: {stat}")
  print(f"Valor p: {p}")

  if p < 0.05:
      print(f"Se rechaza la hipótesis nula. Existe una diferencia significativa entre las medianas de {variable} para los diferentes niveles de ica_cualitativa.")
  else:
      print(f"No se rechaza la hipótesis nula. No existe una diferencia significativa entre las medianas de {variable} para los diferentes niveles de ica_cualitativa.")

  print("---")

"""Podemos confirmar que nuestra hipotesis es verdadera. Las colonias fecales poseen una influencia en la calidad del agua.

**H4: La presencia de materia fecal suspendida en el agua, ¿Se ve influenciada por las bacterias fecales?**

Comenzamos realizando un gráfico de reducción de dimensionalidad PCA de las bacterias fecales pintadas por mat_susp.
"""

new_df = base_completa[['colif_fecales_ufc_100ml', 'escher_coli_ufc_100ml', 'enteroc_ufc_100ml']].copy()

X = new_df
scaler = StandardScaler()
X_scaled = scaler.fit_transform(X)
pca = PCA(n_components=2, whiten=False)
principalComponents = pca.fit_transform(X_scaled)

plt.figure(figsize=(8, 8))
plt.scatter(principalComponents[:, 0], principalComponents[:, 1], c=base_completa['mat_susp'], cmap='viridis')
plt.colorbar(label='Indice de materia fecal')
plt.xlabel('Proyección PCA 1')
plt.ylabel('Proyección PCA 2')
plt.title('Proyección PCA de las bacterias fecales en relacion a la materia fecal suspendida')
plt.grid(True)

plt.xlim([-1, 4])
plt.ylim([-3, 2])

plt.show()

pca.__dict__

# Definir los colores para las categorías 0 y 1
colores = {0: 'orange', 1: 'blue'}  # 0: Ausencia, 1: Presencia
# Para cada variable bacteriana
for variable in variables_bacterianas:
    plt.figure(figsize=(8, 5))

    # Agrupar los datos por 'mat_susp' y calcular la media de la variable bacteriana
    data_agrupada = base_completa.groupby('mat_susp')[variable].mean()

    # Crear el gráfico de barras directamente, sin necesidad de reindexar
    data_agrupada.plot(kind='bar', color=[colores[categoria] for categoria in data_agrupada.index])

    # Configurar el título y las etiquetas
    plt.title(f'Media de {variable} por Ausencia o Presencia')
    plt.xlabel('Categoría de mat_susp (Cualitativa)')
    plt.ylabel(f'Media de {variable}')
    plt.xticks(rotation=0)

    # Mostrar el gráfico
    plt.tight_layout()
    plt.show()

"""Parece ser que hay una diferencia en la media de las variables bacterianas dependiendo de la presencia o no de materia fecal suspendida. Vamos a analizar la normalidad y homocedasiticidad de nuestras variables cuantitativas para buscar un test de hipotesis que se amolde para confirmar o refutar nuestra hipotesis.

Como ya probamos anteriormente que las variables bacterianas no poseen una distribucion normal. Continuamos con el analisis de homocedasticidad mediante Fisher, ya que mat_susp tiene sólo dos grupos.
"""

print("\n")
print('Hipótesis nula (H₀): Las varianzas de los dos grupos son iguales. (Fisher)')
print("\n")

for var in variables_bacterianas:
    grupo_1 = base_completa[base_completa['mat_susp'] == 0][var]
    grupo_2 = base_completa[base_completa['mat_susp'] == 1][var]

    # Test F de Fisher
    stat_f, p_f = f_oneway(grupo_1, grupo_2)

    print(f"Test F de Fisher para {var}:")
    print(f"Estadístico F: {stat_f}")
    print(f"Valor p: {p_f}")

    # Interpretación del valor p
    if p_f > 0.05:
        print("No se rechaza la hipótesis nula: las varianzas son iguales (homocedasticidad).")
    else:
        print("Se rechaza la hipótesis nula: las varianzas son diferentes (heterocedasticidad).")
    print("\n")

"""En este contexto el hecho de que nos haya dado que las tres variables continuas tienen homoscedasticidad tiene sentido. Ya que queremos probar que la presencia de la materia suspendida en el agua no depende sólamente de una variable fecal, si no, de las tres.

Continuamos entonces con el test no paramétrico de Mann Whitney, ya que solo contamos con dos grupos.
"""

from scipy.stats import mannwhitneyu

# Test de Mann-Whitney para cada variable bacteriana en relación a los dos grupos de mat_susp
for var in variables_bacterianas:
    grupo_1 = base_completa[base_completa['mat_susp'] == 0][var]
    grupo_2 = base_completa[base_completa['mat_susp'] == 1][var]
    statistic, p_value = mannwhitneyu(grupo_1, grupo_2)

    print(f"Test de Mann-Whitney para la variable {var}:")
    print(f"Estadístico: {statistic}")
    print(f"Valor p: {p_value}")

    if p_value < 0.05:
        print("Se rechaza la hipótesis nula: Existe una diferencia significativa entre los grupos.")
    else:
        print("No se rechaza la hipótesis nula: No hay evidencia de diferencia significativa entre los grupos.")
    print("---")

"""Viendo los resultados obtenidos con el test, se puede confirmar que la presencia de materia fecal suspendida en el agua se ve influenciada por la presencia de bacterias fecales. Sin embargo solo por coliformes fecales y escherichia coli, no por enterococos.

**La hipótesis H4 queda validada.**

Como la materia fecal está influenciada por dos bacterias fecales, decidimos elegir una de ellas, en este caso las coliformes fecales, para plantear nuestra siguiente hipótesis:

**H5: ¿Las colonias de coliformes fecales presentan un comportamiento estacional?**

Comenzamos realizando un gráfico de barras donde las categorias son las estaciones del año, mostrando la media de coliformes fecales en cada una.
"""

import matplotlib.pyplot as plt

data_temp = pd.DataFrame({
    'campaña': campaña,
    'colif_fecales_ufc_100ml': base_completa['colif_fecales_ufc_100ml']
})

#agrupa por 'campaña' y calcula la media de 'colif_fecales_ufc_100ml'
mean_coliformes = data_temp.groupby('campaña')['colif_fecales_ufc_100ml'].mean()

#colores para cada estación
colores_estaciones = {
    'Verano': 'gold',
    'otoño': 'orange',
    'invierno': 'lightblue',
    'primavera': 'lightgreen'
}

#gráfico de barras
plt.figure(figsize=(6, 6))
mean_coliformes.plot(kind='bar', color=[colores_estaciones[est] for est in mean_coliformes.index])

plt.xlabel('Campaña')
plt.ylabel('Media de coliformes fecales (UFC/100ml)')
plt.title('Media de coliformes fecales por estación')
plt.xticks(rotation=45)
plt.show()

"""Como vemos que hay diferencias entre la cantidad de coliformes fecales por estación, continuamos con el análisis de homocedasiticidad."""

base_completa['campaña'] = campaña #agrego la columna campaña al dataset
verano_data = base_completa[base_completa['campaña'] == 'Verano']['colif_fecales_ufc_100ml']
otono_data = base_completa[base_completa['campaña'] == 'otoño']['colif_fecales_ufc_100ml']
invierno_data = base_completa[base_completa['campaña'] == 'invierno']['colif_fecales_ufc_100ml']
primavera_data = base_completa[base_completa['campaña'] == 'primavera']['colif_fecales_ufc_100ml']

stat, p = levene(verano_data, otono_data, invierno_data, primavera_data)

print("Test de Levene para colif_fecales_ufc_100ml vs. campaña:")
print(f"Estadístico: {stat}")
print(f"Valor p: {p}")

if p > 0.05:
  print("Las varianzas de colif_fecales_ufc_100ml son iguales entre los grupos de campaña.")
else:
  print("Las varianzas de colif_fecales_ufc_100ml no son iguales entre los grupos de campaña.")

"""Como se presenta una distribucion no normal y no hay homocedasticidad, aplicaremos el test de Kruskal-Wallis ya que hay más de dos grupos."""

from scipy.stats import kruskal

#Kruskal-Wallis
stat, p_value = kruskal(verano_data, otono_data, invierno_data, primavera_data)

print(f'Estadístico de prueba: {stat}')
print(f'Valor p: {p_value}')

# Interpretación
if p_value < 0.05:
    print("Rechazamos la hipótesis nula: hay diferencias significativas en la presencia de coliformes fecales entre las estaciones.")
else:
    print("No se rechaza la hipótesis nula: no hay evidencia suficiente de diferencias significativas en la presencia de coliformes fecales entre las estaciones.")

"""Segun lo obtenido con el test, **la H5 queda validada.**

Si la cantidad de coliformes fecales varia estacionalmente, puede que el olor del agua tambien lo haga. Entonces:

**H6: ¿El olor del agua del Rio de la Plata tiene un comportamiento estacional?**

Realizamos primero un gráfico de de barras.
"""

import pandas as pd
import matplotlib.pyplot as plt

contingency_table = pd.crosstab(base_completa['campaña'], base_completa['olores'])
contingency_table.plot(kind='bar', color=['skyblue', 'salmon'])
plt.xlabel('Campaña')
plt.ylabel('Frecuencia')
plt.title('Distribución de olor por estación')
plt.legend(title='olores', labels=['Ausencia', 'Presencia'])
plt.show()

"""Vemos que parece no haber un comportamiento estacional para la variable olores, asi que decidimos hacer la prueba de Chi-cuadrado (ya que las dos variables son cualitativas) para poder refutar la hipótesis."""

from scipy.stats import chi2_contingency

#tabla de contingencia
contingency_table = pd.crosstab(base_completa['campaña'], base_completa['olores'])

#chi-cuadrado
chi2, p, dof, expected = chi2_contingency(contingency_table)

print(f"Estadístico chi-cuadrado: {chi2}")
print(f"Valor p: {p}")
print(f"Grados de libertad: {dof}")
print("Tabla de valores esperados:")
print(expected)

alpha = 0.05
if p < alpha:
    print("Se rechaza la hipótesis nula: Existe una asociación significativa entre olores y campaña.")
else:
    print("No se rechaza la hipótesis nula: No hay evidencia suficiente de asociación entre olores y campaña.")

"""**La H6 no puede ser validad ni refutada.** No podemos determinar que el olor del agua del Rio de la Plata tiene un comportamiento estacional, no contabamos con suficientes datos del tipo "presencia".

Sin embargo, tal vez la materia fecal suspendida puede llegar a tener un comportamiento estacional, ya que por las hipótesis H4 sabemos que algunas bacterias fecales influyen en la cantidad de materia fecal en el agua y que además las coliformes fecales tienen un comportamiento estacional.

**H7: ¿La materia fecal suspendida en el agua tiene un comportamiento estacional?**

Nuevamente realizamos un gráfico de barras.
"""

import pandas as pd
import matplotlib.pyplot as plt

contingency_table = pd.crosstab(base_completa['campaña'], base_completa['mat_susp'])
contingency_table.plot(kind='bar', color=['skyblue', 'salmon'])
plt.xlabel('Campaña')
plt.ylabel('Frecuencia')
plt.title('Distribución de la materia fecal suspendida por estación')
plt.legend(title='mat_susp', labels=['Ausencia', 'Presencia'])
plt.show()

"""Contamos con más datos en mat_susp y parece haber un posible comportamiento. Nuevamente aplicamos la prueba de Chi-cuadrado."""

from scipy.stats import chi2_contingency

#tabla de contingencia
contingency_table = pd.crosstab(base_completa['mat_susp'], base_completa['campaña'])

#chi-cuadrado
chi2, p, dof, expected = chi2_contingency(contingency_table)

print(f"Estadístico chi-cuadrado: {chi2}")
print(f"Valor p: {p}")
print(f"Grados de libertad: {dof}")
print("Tabla de valores esperados:")
print(expected)

alpha = 0.05
if p < alpha:
    print("Se rechaza la hipótesis nula: Existe una asociación significativa entre mat_susp y campaña.")
else:
    print("No se rechaza la hipótesis nula: No hay evidencia suficiente de asociación entre mat_susp y campaña.")

"""**La H7 queda validada.**"""